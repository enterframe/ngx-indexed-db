{"version":3,"sources":["ng://ngx-indexed-db/lib/ngx-indexed-db.ts","ng://ngx-indexed-db/utils/index.ts","ng://ngx-indexed-db/lib/ngx-indexed-db.meta.ts","ng://ngx-indexed-db/lib/ngx-indexed-db.service.ts","ng://ngx-indexed-db/lib/ngxindexeddb.module.ts"],"names":["indexedDB","window","mozIndexedDB","webkitIndexedDB","msIndexedDB","openDatabase","dbName","version","upgradeCallback","Promise","resolve","reject","db","request","open","onsuccess","event","result","onerror","error","onupgradeneeded","console","log","validateBeforeTransaction","storeName","objectStoreNames","contains","validateStoreName","createTransaction","options","trans","transaction","dbMode","oncomplete","complete","onabort","abort","optionsGenerator","type","e","CONFIG_TOKEN","InjectionToken","NgxIndexedDBService","dbConfig","this","name","Error","storeSchemas","migrationFactory","objectStoresMeta","database","forEach","storeSchema","store","objectStore_1","createObjectStore","storeConfig","schema","createIndex","keypath","storeMigrations","Object","keys","map","k","parseInt","filter","v","oldVersion","sort","a","b","close","target","defineProperty","prototype","_currentStore","add","value","key","_this","then","DBMode","objectStore","evt","getByKey","get","getByID","id","getAll","_a","ResultAll","update","put","deleteRecord","delete","clear","openCursor","cursorCallback","keyRange","getByIndex","indexName","index","Injectable","Inject","args","NgxIndexedDBModule","forRoot","ngModule","providers","provide","useValue","NgModule","declarations","imports","CommonModule"],"mappings":"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","sourcesContent":["export interface ObjectStoreMeta {\n\tstore: string;\n\tstoreConfig: { keyPath: string; autoIncrement: boolean; [key: string]: any };\n\tstoreSchema: ObjectStoreSchema[];\n}\n\nexport interface ObjectStoreSchema {\n\tname: string;\n\tkeypath: string | string[];\n\toptions: { unique: boolean; [key: string]: any };\n}\nexport type Key = string | number | Date | ArrayBufferView | ArrayBuffer | IDBArrayKey | IDBKeyRange;\nexport interface IndexDetails {\n\tindexName: string;\n\torder: string;\n}\nexport interface RequestEventTarget<T> extends EventTarget {\n\tresult: T | T[];\n}\n\nexport interface RequestEvent<T> extends Event {\n\ttarget: RequestEventTarget<T>;\n}\n\nconst indexedDB: IDBFactory =\n\twindow.indexedDB || (<any>window).mozIndexedDB || (<any>window).webkitIndexedDB || (<any>window).msIndexedDB;\n\nexport function openDatabase(dbName: string, version: number, upgradeCallback?: Function) {\n\treturn new Promise<IDBDatabase>((resolve, reject) => {\n\t\tconst request = indexedDB.open(dbName, version);\n\t\tlet db: IDBDatabase;\n\t\trequest.onsuccess = (event: Event) => {\n\t\t\tdb = request.result;\n\t\t\tresolve(db);\n\t\t};\n\t\trequest.onerror = (event: Event) => {\n\t\t\treject(`IndexedDB error: ${request.error}`);\n\t\t};\n\t\tif (typeof upgradeCallback === 'function') {\n\t\t\trequest.onupgradeneeded = (event: Event) => {\n\t\t\t\tconsole.log('checkout');\n\t\t\t\tupgradeCallback(event, db);\n\t\t\t};\n\t\t}\n\t});\n}\n\nexport function CreateObjectStore(\n\tdbName: string,\n\tversion: number,\n\tstoreSchemas: ObjectStoreMeta[],\n\tmigrationFactory?: () => { [key: number]: (db: IDBDatabase, transaction: IDBTransaction) => void }\n) {\n\tconst request: IDBOpenDBRequest = indexedDB.open(dbName, version);\n\n\trequest.onupgradeneeded = function(event: IDBVersionChangeEvent) {\n\t\tconst database: IDBDatabase = (event.target as any).result;\n\n\t\tstoreSchemas.forEach((storeSchema: ObjectStoreMeta) => {\n\t\t\tif (!database.objectStoreNames.contains(storeSchema.store)) {\n\t\t\t\tconst objectStore = database.createObjectStore(storeSchema.store, storeSchema.storeConfig);\n\t\t\t\tstoreSchema.storeSchema.forEach((schema: ObjectStoreSchema) => {\n\t\t\t\t\tobjectStore.createIndex(schema.name, schema.keypath, schema.options);\n\t\t\t\t});\n\t\t\t}\n\t\t});\n\n\t\tconst storeMigrations = migrationFactory && migrationFactory();\n\t\tif (storeMigrations) {\n\t\t\tObject.keys(storeMigrations)\n\t\t\t\t.map(k => parseInt(k, 10))\n\t\t\t\t.filter(v => v > event.oldVersion)\n\t\t\t\t.sort((a, b) => a - b)\n\t\t\t\t.forEach(v => {\n\t\t\t\t\tstoreMigrations[v](database, request.transaction);\n\t\t\t\t});\n\t\t}\n\n\t\tdatabase.close();\n\t};\n\n\trequest.onsuccess = function(e: any) {\n\t\te.target.result.close();\n\t};\n}\n\nexport enum DBMode {\n\treadonly = 'readonly',\n\treadwrite = 'readwrite'\n}\n","export interface Options {\n\tstoreName: string;\n\tdbMode: IDBTransactionMode;\n\terror: (e: Event) => any;\n\tcomplete: (e: Event) => any;\n\tabort?: any;\n}\n\nexport function validateStoreName(db: IDBDatabase, storeName: string) {\n\treturn db.objectStoreNames.contains(storeName);\n}\n\nexport function validateBeforeTransaction(db: IDBDatabase, storeName: string, reject: Function) {\n\tif (!db) {\n\t\treject('You need to use the openDatabase function to create a database before you query it!');\n\t}\n\tif (!validateStoreName(db, storeName)) {\n\t\treject(`objectStore does not exists: ${storeName}`);\n\t}\n}\n\nexport function createTransaction(db: IDBDatabase, options: Options): IDBTransaction {\n\tlet trans: IDBTransaction = db.transaction(options.storeName, options.dbMode);\n\ttrans.onerror = options.error;\n\ttrans.oncomplete = options.complete;\n\ttrans.onabort = options.abort;\n\treturn trans;\n}\n\nexport function optionsGenerator(type: any, storeName: any, reject: Function, resolve: Function): Options {\n\treturn {\n\t\tstoreName: storeName,\n\t\tdbMode: type,\n\t\terror: (e: Event) => {\n\t\t\treject(e);\n\t\t},\n\t\tcomplete: (e: Event) => {\n\t\t\tresolve();\n\t\t},\n\t\tabort: (e: Event) => {\n\t\t\treject(e);\n\t\t}\n\t};\n}\n","import { InjectionToken } from '@angular/core';\n\nexport interface DBConfig {\n\tname: string;\n\tversion: number;\n\tobjectStoresMeta: ObjectStoreMeta[];\n\tmigrationFactory?: () => { [key: number]: (db: IDBDatabase, transaction: IDBTransaction) => void };\n}\n\nexport interface ObjectStoreMeta {\n\tstore: string;\n\tstoreConfig: { keyPath: string; autoIncrement: boolean; [key: string]: any };\n\tstoreSchema: ObjectStoreSchema[];\n}\n\nexport interface ObjectStoreSchema {\n\tname: string;\n\tkeypath: string;\n\toptions: { unique: boolean; [key: string]: any };\n}\n\nexport const CONFIG_TOKEN = new InjectionToken<DBConfig>(null);\n","import { Injectable, Inject } from '@angular/core';\nimport { openDatabase, DBMode, Key, RequestEvent, CreateObjectStore } from './ngx-indexed-db';\nimport { createTransaction, optionsGenerator, validateBeforeTransaction } from '../utils';\nimport { CONFIG_TOKEN, DBConfig } from './ngx-indexed-db.meta';\n\n@Injectable()\nexport class NgxIndexedDBService {\n\tset currentStore(_currentStore: string) {\n\t\tthis._currentStore = _currentStore;\n\t}\n\tget currentStore(): string {\n\t\treturn this._currentStore;\n\t}\n\tprivate _currentStore: string;\n\n\tconstructor(@Inject(CONFIG_TOKEN) private dbConfig: DBConfig) {\n\t\tif (!dbConfig.name) {\n\t\t\tthrow new Error('NgxIndexedDB: Please, provide the dbName in the configuration');\n\t\t}\n\t\tif (!dbConfig.version) {\n\t\t\tthrow new Error('NgxIndexedDB: Please, provide the db version in the configuration');\n\t\t}\n\t\tCreateObjectStore(dbConfig.name, dbConfig.version, dbConfig.objectStoresMeta, dbConfig.migrationFactory);\n\t}\n\n\tadd<T>(value: T, key?: any) {\n\t\treturn new Promise<number>((resolve, reject) => {\n\t\t\topenDatabase(this.dbConfig.name, this.dbConfig.version).then((db: IDBDatabase) => {\n\t\t\t\tlet transaction = createTransaction(\n\t\t\t\t\t\tdb,\n\t\t\t\t\t\toptionsGenerator(DBMode.readwrite, this._currentStore, reject, resolve)\n\t\t\t\t\t),\n\t\t\t\t\tobjectStore = transaction.objectStore(this._currentStore);\n\t\t\t\tlet request = objectStore.add(value, key);\n\t\t\t\trequest.onsuccess = (evt: any) => {\n\t\t\t\t\tkey = evt.target.result;\n\t\t\t\t\tresolve(key);\n\t\t\t\t};\n\t\t\t});\n\t\t});\n\t}\n\n\tgetByKey<T>(key: any) {\n\t\treturn new Promise<any>((resolve, reject) => {\n\t\t\topenDatabase(this.dbConfig.name, this.dbConfig.version).then((db: IDBDatabase) => {\n\t\t\t\tlet transaction = createTransaction(\n\t\t\t\t\t\tdb,\n\t\t\t\t\t\toptionsGenerator(DBMode.readonly, this._currentStore, reject, resolve)\n\t\t\t\t\t),\n\t\t\t\t\tobjectStore = transaction.objectStore(this._currentStore);\n\t\t\t\tlet request = objectStore.get(key);\n\t\t\t\trequest.onsuccess = function(event: Event) {\n\t\t\t\t\tresolve((<any>event.target).result);\n\t\t\t\t};\n\t\t\t\trequest.onerror = function(event: Event) {\n\t\t\t\t\treject(event);\n\t\t\t\t};\n\t\t\t});\n\t\t});\n\t}\n\n\tgetByID<T>(id: string | number) {\n\t\treturn new Promise<T>((resolve, reject) => {\n\t\t\topenDatabase(this.dbConfig.name, this.dbConfig.version).then((db: IDBDatabase) => {\n\t\t\t\tvalidateBeforeTransaction(db, this._currentStore, reject);\n\t\t\t\tlet transaction = createTransaction(\n\t\t\t\t\t\tdb,\n\t\t\t\t\t\toptionsGenerator(DBMode.readonly, this._currentStore, reject, resolve)\n\t\t\t\t\t),\n\t\t\t\t\tobjectStore = transaction.objectStore(this._currentStore),\n\t\t\t\t\trequest: IDBRequest;\n\t\t\t\trequest = objectStore.get(+id);\n\t\t\t\trequest.onsuccess = function(event: Event) {\n\t\t\t\t\tresolve((event.target as any).result as T);\n\t\t\t\t};\n\t\t\t});\n\t\t});\n\t}\n\n\tgetAll<T>() {\n\t\treturn new Promise<T[]>((resolve, reject) => {\n\t\t\topenDatabase(this.dbConfig.name, this.dbConfig.version).then(db => {\n\t\t\t\tvalidateBeforeTransaction(db, this._currentStore, reject);\n\t\t\t\tlet transaction = createTransaction(\n\t\t\t\t\t\tdb,\n\t\t\t\t\t\toptionsGenerator(DBMode.readonly, this._currentStore, reject, resolve)\n\t\t\t\t\t),\n\t\t\t\t\tobjectStore = transaction.objectStore(this._currentStore),\n\t\t\t\t\tresult: Array<any> = [];\n\n\t\t\t\tconst request: IDBRequest = objectStore.getAll();\n\n\t\t\t\trequest.onerror = function(e) {\n\t\t\t\t\treject(e);\n\t\t\t\t};\n\t\t\t\trequest.onsuccess = function({ target: { result: ResultAll } }: RequestEvent<T>) {\n\t\t\t\t\tresolve(ResultAll as T[]);\n\t\t\t\t};\n\t\t\t});\n\t\t});\n\t}\n\n\tupdate<T>(value: T, key?: any) {\n\t\treturn new Promise<any>((resolve, reject) => {\n\t\t\topenDatabase(this.dbConfig.name, this.dbConfig.version).then(db => {\n\t\t\t\tvalidateBeforeTransaction(db, this._currentStore, reject);\n\t\t\t\tlet transaction = createTransaction(\n\t\t\t\t\t\tdb,\n\t\t\t\t\t\toptionsGenerator(DBMode.readwrite, this._currentStore, reject, resolve)\n\t\t\t\t\t),\n\t\t\t\t\tobjectStore = transaction.objectStore(this._currentStore);\n\t\t\t\ttransaction.oncomplete = event => {\n\t\t\t\t\tresolve(event);\n\t\t\t\t};\n\t\t\t\tobjectStore.put(value, key);\n\t\t\t});\n\t\t});\n\t}\n\n\tdeleteRecord(key: Key) {\n\t\treturn new Promise<any>((resolve, reject) => {\n\t\t\topenDatabase(this.dbConfig.name, this.dbConfig.version).then(db => {\n\t\t\t\tvalidateBeforeTransaction(db, this._currentStore, reject);\n\t\t\t\tlet transaction = createTransaction(\n\t\t\t\t\t\tdb,\n\t\t\t\t\t\toptionsGenerator(DBMode.readwrite, this._currentStore, reject, resolve)\n\t\t\t\t\t),\n\t\t\t\t\tobjectStore = transaction.objectStore(this._currentStore);\n\t\t\t\tlet request = objectStore.delete(key);\n\t\t\t\trequest.onsuccess = event => {\n\t\t\t\t\tresolve(event);\n\t\t\t\t};\n\t\t\t});\n\t\t});\n\t}\n\n\tclear() {\n\t\treturn new Promise<any>((resolve, reject) => {\n\t\t\topenDatabase(this.dbConfig.name, this.dbConfig.version).then(db => {\n\t\t\t\tvalidateBeforeTransaction(db, this._currentStore, reject);\n\t\t\t\tlet transaction = createTransaction(\n\t\t\t\t\t\tdb,\n\t\t\t\t\t\toptionsGenerator(DBMode.readwrite, this._currentStore, reject, resolve)\n\t\t\t\t\t),\n\t\t\t\t\tobjectStore = transaction.objectStore(this._currentStore);\n\t\t\t\tobjectStore.clear();\n\t\t\t\ttransaction.oncomplete = event => {\n\t\t\t\t\tresolve();\n\t\t\t\t};\n\t\t\t});\n\t\t});\n\t}\n\n\tdelete(key: any) {\n\t\treturn new Promise<any>((resolve, reject) => {\n\t\t\topenDatabase(this.dbConfig.name, this.dbConfig.version).then(db => {\n\t\t\t\tvalidateBeforeTransaction(db, this._currentStore, reject);\n\t\t\t\tlet transaction = createTransaction(\n\t\t\t\t\t\tdb,\n\t\t\t\t\t\toptionsGenerator(DBMode.readwrite, this._currentStore, reject, resolve)\n\t\t\t\t\t),\n\t\t\t\t\tobjectStore = transaction.objectStore(this._currentStore);\n\t\t\t\tobjectStore['delete'](key);\n\t\t\t});\n\t\t});\n\t}\n\n\topenCursor(cursorCallback: (event: Event) => void, keyRange?: IDBKeyRange) {\n\t\treturn new Promise<void>((resolve, reject) => {\n\t\t\topenDatabase(this.dbConfig.name, this.dbConfig.version).then(db => {\n\t\t\t\tvalidateBeforeTransaction(db, this._currentStore, reject);\n\t\t\t\tlet transaction = createTransaction(\n\t\t\t\t\t\tdb,\n\t\t\t\t\t\toptionsGenerator(DBMode.readonly, this._currentStore, reject, resolve)\n\t\t\t\t\t),\n\t\t\t\t\tobjectStore = transaction.objectStore(this._currentStore),\n\t\t\t\t\trequest = objectStore.openCursor(keyRange);\n\n\t\t\t\trequest.onsuccess = (event: Event) => {\n\t\t\t\t\tcursorCallback(event);\n\t\t\t\t\tresolve();\n\t\t\t\t};\n\t\t\t});\n\t\t});\n\t}\n\n\tgetByIndex(indexName: string, key: any) {\n\t\treturn new Promise<any>((resolve, reject) => {\n\t\t\topenDatabase(this.dbConfig.name, this.dbConfig.version).then(db => {\n\t\t\t\tvalidateBeforeTransaction(db, this._currentStore, reject);\n\t\t\t\tlet transaction = createTransaction(\n\t\t\t\t\t\tdb,\n\t\t\t\t\t\toptionsGenerator(DBMode.readonly, this._currentStore, reject, resolve)\n\t\t\t\t\t),\n\t\t\t\t\tobjectStore = transaction.objectStore(this._currentStore),\n\t\t\t\t\tindex = objectStore.index(indexName),\n\t\t\t\t\trequest = index.get(key);\n\t\t\t\trequest.onsuccess = (event: Event) => {\n\t\t\t\t\tresolve((<IDBOpenDBRequest>event.target).result);\n\t\t\t\t};\n\t\t\t});\n\t\t});\n\t}\n}\n","import { NgModule, ModuleWithProviders, InjectionToken } from '@angular/core';\nimport { CommonModule } from '@angular/common';\nimport { NgxIndexedDBService } from './ngx-indexed-db.service';\nimport { DBConfig, CONFIG_TOKEN } from './ngx-indexed-db.meta';\n\n@NgModule({\n\tdeclarations: [],\n\timports: [CommonModule]\n})\nexport class NgxIndexedDBModule {\n\tstatic forRoot(dbConfig: DBConfig): ModuleWithProviders<NgxIndexedDBModule> {\n\t\treturn {\n\t\t\tngModule: NgxIndexedDBModule,\n\t\t\tproviders: [NgxIndexedDBService, { provide: CONFIG_TOKEN, useValue: dbConfig }]\n\t\t};\n\t}\n}\n"]}